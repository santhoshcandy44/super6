package com.super6.pot.api.auth.managers.socketimport android.util.Logimport com.super6.pot.Appimport com.super6.pot.BuildConfigimport com.super6.pot.api.auth.managers.CriticalListenerimport com.super6.pot.api.auth.managers.RefreshTokenManagerimport com.super6.pot.api.auth.managers.RetryListenerimport com.super6.pot.api.auth.managers.TokenManagerimport com.super6.pot.app.database.daos.chat.ChatUserDaoimport com.super6.pot.app.database.models.chat.ChatMessageStatusimport com.super6.pot.app.database.models.chat.ChatMessageTypeimport com.super6.pot.app.database.models.chat.Messageimport com.super6.pot.app.database.daos.chat.MessageDaoimport com.super6.pot.app.database.daos.chat.MessageMediaMetaDataDaoimport com.super6.pot.app.database.models.chat.MessageMediaMetadataimport com.super6.pot.ui.auth.repos.DecryptionStatusimport com.super6.pot.ui.auth.repos.decryptMessageimport com.super6.pot.ui.auth.repos.encryptMessageimport com.super6.pot.ui.managers.UserSharedPreferencesManagerimport com.super6.pot.app.workers.helpers.ChatMessageHandlerWorkerHelperimport com.super6.pot.utils.LogUtils.TAGimport io.socket.client.Ackimport io.socket.client.IOimport io.socket.client.Managerimport io.socket.client.Socketimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.asStateFlowimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlinx.coroutines.withContextimport org.json.JSONObjectimport java.io.IOExceptionimport java.net.SocketExceptionimport java.net.SocketTimeoutExceptionimport java.net.UnknownHostExceptionimport javax.inject.Injectimport javax.inject.Singleton@Singletonclass SocketManager @Inject constructor(    val application: App,    val tokenManager: TokenManager,    val messageDao: MessageDao,    private val fileMetaDataDao: MessageMediaMetaDataDao,    val chatUserDao: ChatUserDao) {    init {        UserSharedPreferencesManager.initialize(application.applicationContext)    }    private var socket: Socket? = null    // Use MutableStateFlow to hold and expose the current socket state    private val _socketFlow = MutableStateFlow<Socket?>(null)    val socketFlow = _socketFlow.asStateFlow()    // Use MutableStateFlow to hold and expose the current socket state    private val _statusFlow = MutableStateFlow(false)    val statusFlow = _statusFlow.asStateFlow()    // Function to return the current socket and connect if necessary    fun getSocket(        onSuccess: (Socket) -> Unit = {},        onError: () -> Unit = {},        isBackground: Boolean = false,        isForceNew: Boolean = false,        queryParam: String = ""    ): Socket {        val userId = UserSharedPreferencesManager.userId        connect(            userId,            onSuccess = onSuccess,            onError = onError,            isBackground = isBackground,            isForceNew = isForceNew,            queryParam = queryParam        ) // Ensure the socket is connected before returning        return socket!!    }    var isBackgroundSocket = false    // Function to establish a socket connection    fun connect(        userId: Long,        onSuccess: (Socket) -> Unit,        onError: () -> Unit,        isBackground: Boolean,        isForceNew: Boolean = false,        queryParam: String = ""    ) {        isBackgroundSocket = isBackground        if (socket != null && !isForceNew) {            socket?.let {                if (!it.connected()) {                    val newSocket = it.connect()// Reconnect if not already connected                    onSuccess(it)                } else {                    onSuccess(it)                }            } ?: run {                onError()            }        } else {            if (isForceNew) {                socket?.let {                    if (it.connected()) {                        it.disconnect()                    }                    socket = null                }            }            try {                val accessToken = tokenManager.getAccessToken()                // Initialize the socket with the server URL                socket = IO.socket(BuildConfig.SOCKET_BASE_URL, IO.Options().apply {                    forceNew = true                    reconnection = true // Enable reconnection                    reconnectionAttempts = Int.MAX_VALUE // Unlimited reconnection attempts                    reconnectionDelay = 1000 // Initial reconnection delay in milliseconds                    reconnectionDelayMax = 1000 // Maximum delay for reconnection                    // Include additional query parameters                    query = queryParam// Replace with your query parameters                    // Include auth token in the connection options                    auth = mapOf("token" to accessToken) // Replace with your actual token                })                // Socket event listeners                socket?.on(Socket.EVENT_CONNECT) {                    Log.d(TAG, "EVENT_CONNECT")                    startHeartbeat()                    socket?.emit("chat:userJoined", JSONObject().apply {                        put("user_id", userId)                        put("is_background", isBackground)                    })                    if (!isBackground) {                        CoroutineScope(Dispatchers.IO).launch {                            val queuedMessages = messageDao.getQueuedMessages()                            queuedMessages.forEach { queuedMessage ->                                if (socket!!.connected()) {                                    if (queuedMessage.type == ChatMessageType.TEXT) {                                        val jsonData = JSONObject().apply {                                            put("user_id", userId)                                            put("recipient_id", queuedMessage.recipientId)                                        }                                        val publicKeyWithVersion =                                            chatUserDao.getPublicKeyWithVersionByRecipientIdRaw(                                                queuedMessage.recipientId                                            )                                        publicKeyWithVersion?.let {                                            try {                                                jsonData.put(                                                    "message",                                                    encryptMessage(                                                        queuedMessage.content,                                                        it.publicKey                                                    )                                                )                                                jsonData.put("key_version", it.keyVersion)                                                jsonData.put("message_id", queuedMessage.id)                                                jsonData.put("category", "text")                                                jsonData.put(                                                    "reply_id",                                                    queuedMessage.senderMessageId                                                )                                                jsonData.put(                                                    "type",                                                    if (queuedMessage.replyId != -1L) "reply" else "normal"                                                )                                                // Emit the chat message with an acknowledgment callback                                                socket!!.emit("chat:chatMessage",                                                    jsonData,                                                    Ack { args ->                                                        // Handle the acknowledgment from the server                                                        if (args.isNotEmpty()) {                                                            val response = args[0] as String                                                            val data = args[1] as? JSONObject                                                            val status = data?.optString("status")                                                            if (status != null && status == "KEY_ERROR") {                                                                val recipientId =                                                                    data.getLong("recipient_id")                                                                val publicKey =                                                                    data.getString("publicKey")                                                                val keyVersion =                                                                    data.getLong("keyVersion")                                                                chatUserDao.updatePublicKeyByRecipientId(                                                                    recipientId,                                                                    publicKey,                                                                    keyVersion                                                                )                                                                CoroutineScope(Dispatchers.IO).launch {                                                                    messageDao.updateMessageStatus(                                                                        queuedMessage.id,                                                                        ChatMessageStatus.QUEUED                                                                    )                                                                    val queuedMessagesRedeliver =                                                                        messageDao.getQueuedMessages()                                                                    queuedMessagesRedeliver.forEach { queuedMessageRedeliver ->                                                                        if (socket!!.connected()) {                                                                            try {                                                                                val queuedData =                                                                                    JSONObject().apply {                                                                                        put(                                                                                            "user_id",                                                                                            userId                                                                                        )                                                                                        put(                                                                                            "recipient_id",                                                                                            queuedMessageRedeliver.recipientId                                                                                        )                                                                                        put(                                                                                            "message",                                                                                            encryptMessage(                                                                                                queuedMessageRedeliver.content,                                                                                                publicKey                                                                                            )                                                                                        )                                                                                        put(                                                                                            "key_version",                                                                                            keyVersion                                                                                        )                                                                                        put(                                                                                            "message_id",                                                                                            queuedMessageRedeliver.id                                                                                        )                                                                                        put(                                                                                            "reply_id",                                                                                            queuedMessageRedeliver.replyId                                                                                        )                                                                                        put(                                                                                            "type",                                                                                            if (queuedMessageRedeliver.replyId != -1L) "reply" else "normal"                                                                                        )                                                                                        put(                                                                                            "category",                                                                                            "text"                                                                                        )                                                                                    }                                                                                socket!!.emit(                                                                                    "chat:chatMessage",                                                                                    queuedData,                                                                                    Ack { args ->                                                                                        // Handle the acknowledgment from the server                                                                                        if (args.isNotEmpty()) {                                                                                            val queuedResponse =                                                                                                args[0] as String                                                                                            val queuedReceivedData =                                                                                                args[1] as? JSONObject                                                                                            val queuedStatus =                                                                                                queuedReceivedData?.optString(                                                                                                    "status"                                                                                                )                                                                                            if (queuedStatus != null && queuedStatus == "KEY_ERROR") {                                                                                                CoroutineScope(                                                                                                    Dispatchers.IO                                                                                                ).launch {                                                                                                    messageDao.updateMessageStatus(                                                                                                        queuedMessageRedeliver.id,                                                                                                        ChatMessageStatus.FAILED                                                                                                    )                                                                                                }                                                                                            } else if (queuedStatus != null && queuedStatus == "USER_NOT_ACTIVE_ERROR") {                                                                                                CoroutineScope(                                                                                                    Dispatchers.IO                                                                                                ).launch {                                                                                                    messageDao.updateMessageStatus(                                                                                                        queuedMessageRedeliver.id,                                                                                                        ChatMessageStatus.FAILED                                                                                                    )                                                                                                }                                                                                            } else {                                                                                                CoroutineScope(                                                                                                    Dispatchers.IO                                                                                                ).launch {                                                                                                    messageDao.updateMessageStatus(                                                                                                        queuedMessageRedeliver.id,                                                                                                        ChatMessageStatus.SENT                                                                                                    )                                                                                                }                                                                                            }                                                                                            Log.d(TAG, "Queued message delivered acknowledged by server")                                                                                        }                                                                                    })                                                                            } catch (e: Exception) {                                                                                e.printStackTrace()                                                                                messageDao.updateMessageStatus(                                                                                    queuedMessageRedeliver.id,                                                                                    ChatMessageStatus.FAILED                                                                                )                                                                            }                                                                        }                                                                    }                                                                }                                                            } else if (status != null && status == "USER_NOT_ACTIVE_ERROR") {                                                                CoroutineScope(Dispatchers.IO).launch {                                                                    messageDao.updateMessageStatus(                                                                        queuedMessage.id,                                                                        ChatMessageStatus.FAILED                                                                    )                                                                }                                                            } else {                                                                CoroutineScope(Dispatchers.IO).launch {                                                                    messageDao.updateMessageStatus(                                                                        queuedMessage.id,                                                                        ChatMessageStatus.SENT                                                                    )                                                                }                                                                Log.e(TAG, "Message sent & acknowledged")                                                            }                                                        }                                                    })                                            } catch (e: Exception) {                                                e.printStackTrace()                                                messageDao.updateMessageStatus(                                                    queuedMessage.id,                                                    ChatMessageStatus.FAILED                                                )                                            }                                        } ?: run {                                            socket!!.emit(                                                "chat:queryPublicKey",                                                jsonData,                                                Ack { args ->                                                    // Handle the acknowledgment from the server                                                    if (args.isNotEmpty()) {                                                        //val message = args[0] as String                                                        val response = args[1] as JSONObject                                                        val recipientId =                                                            response.getLong("recipient_id")                                                        val publicKey =                                                            response.getString("publicKey")                                                        val keyVersion =                                                            response.getLong("keyVersion")                                                        chatUserDao.updatePublicKeyByRecipientId(                                                            recipientId,                                                            publicKey,                                                            keyVersion                                                        )                                                        CoroutineScope(Dispatchers.IO)                                                            .launch {                                                                messageDao.updateMessageStatus(                                                                    queuedMessage.id,                                                                    ChatMessageStatus.QUEUED                                                                )                                                                val queuedMessages2 =                                                                    messageDao.getQueuedMessages()                                                                queuedMessages2.forEach {                                                                    if (socket!!.connected()) {                                                                        try {                                                                            val queuedData =                                                                                JSONObject().apply {                                                                                    put(                                                                                        "user_id",                                                                                        userId                                                                                    )                                                                                    put(                                                                                        "recipient_id",                                                                                        it.recipientId                                                                                    )                                                                                    put(                                                                                        "message",                                                                                        encryptMessage(                                                                                            it.content,                                                                                            publicKey                                                                                        )                                                                                    )                                                                                    put(                                                                                        "key_version",                                                                                        keyVersion                                                                                    )                                                                                    put(                                                                                        "message_id",                                                                                        it.id                                                                                    )                                                                                    put(                                                                                        "reply_id",                                                                                        it.replyId                                                                                    )                                                                                    put(                                                                                        "type",                                                                                        if (it.replyId != -1L) "reply" else "normal"                                                                                    )                                                                                    put(                                                                                        "category",                                                                                        "text"                                                                                    )                                                                                }                                                                            socket!!.emit(                                                                                "chat:chatMessage",                                                                                queuedData,                                                                                Ack { args ->                                                                                    // Handle the acknowledgment from the server                                                                                    if (args.isNotEmpty()) {                                                                                        val queuedResponse =                                                                                            args[0] as String                                                                                        CoroutineScope(                                                                                            Dispatchers.IO                                                                                        )                                                                                            .launch {                                                                                                messageDao.updateMessageStatus(                                                                                                    it.id,                                                                                                    ChatMessageStatus.SENT                                                                                                )                                                                                            }                                                                                        Log.e(TAG, "Queued message delivered & acknowledged")                                                                                    }                                                                                })                                                                        } catch (e: Exception) {                                                                            messageDao.updateMessageStatus(                                                                                it.id,                                                                                ChatMessageStatus.FAILED                                                                            )                                                                            e.printStackTrace()                                                                        }                                                                    }                                                                }                                                            }                                                    } else {                                                        CoroutineScope(Dispatchers.IO)                                                            .launch {                                                                messageDao.updateMessageStatus(                                                                    queuedMessage.id,                                                                    ChatMessageStatus.FAILED                                                                )                                                            }                                                    }                                                })                                        }                                    }                                }                            }                        }                    }                    if (isBackground) {                        socket?.let {                            onSuccess(it)                        } ?: run {                            onError()                        }                        return@on                    }                    _statusFlow.value = true                    _socketFlow.value = socket // Emit new socket on connection                    socket?.let {                        onSuccess(it)                    } ?: run {                        onError()                    }                }                if (!isBackground) {                    socket?.on("chat:offlineMessages") { args ->                        val data = args[0] as JSONObject                        chatMessageProcessor(data, userId)                    }                    socket?.on("chat:messageStatus") { args ->                        val data = args[0] as JSONObject                        val sender = data.getInt("sender")                        val recipientId = data.getInt("recipient_id")                        val messageId = data.getLong("message_id")                        val status = data.getString("status")                        CoroutineScope(Dispatchers.IO).launch {                            if (status == "delivered") {                                messageDao.updateMessageStatus(                                    messageId,                                    ChatMessageStatus.DELIVERED                                )                            }                            else if (status=="sent"){                                messageDao.updateMessageStatus(                                    messageId,                                    ChatMessageStatus.SENT                                )                            }                            else {                                messageDao.updateMessageStatus(                                    messageId,                                    ChatMessageStatus.FAILED                                )                            }                            // Send acknowledgment back to the server                            val acknowledgment = JSONObject().apply {                                put("success", true) // Indicate acknowledgment success                                put("sender", sender) // Include the message ID for reference                                put("message_id", messageId) // Include the message ID for reference                            }                            // Check if an acknowledgment callback is provided and call it                            (args[1] as? Ack)?.call(acknowledgment)                        }                    }                    socket?.on("chat:chatMessage") { args ->                        val data = args[0] as JSONObject                        chatMessageProcessor(data, userId)                    }                    socket?.on("chat:check") { args ->                        val callback = args[1] as Ack                        callback.call()                    }                }                socket?.on(Socket.EVENT_CONNECT_ERROR) { args ->                    if (args[0] is JSONObject) {                        destroySocket()                        val error = args[0] as JSONObject                        val errorMessage = error.optString("message") // Get the error message                        //Handle specific error message                        if (errorMessage.contains("AUTHENTICATION_ERROR_NO_TOKEN_PROVIDED")                            || errorMessage.contains("AUTHENTICATION_ERROR_INVALID_TOKEN")                        ) {                            runBlocking {                                delay(1000)                                connect(                                    userId,                                    onSuccess,                                    onError,                                    isBackground,                                    true,                                    queryParam                                )                            }                        } else if (errorMessage.contains("AUTHENTICATION_ERROR_TOKEN_EXPIRED")) {                            CoroutineScope(Dispatchers.IO).launch {                                RefreshTokenManager.onRefreshAccessToken(                                    tokenManager,                                    accessToken,                                    object : CriticalListener {                                        override fun onSuccess(newToken: String) {                                            destroySocket()                                            connect(                                                userId,                                                onSuccess,                                                onError,                                                isBackground,                                                true,                                                queryParam                                            )                                        }                                        override fun onError(e: Exception?) {                                            if (e != null) {                                                e.printStackTrace()                                            } else {                                                destroySocket()                                                connect(                                                    userId,                                                    onSuccess,                                                    onError,                                                    isBackground,                                                    true,                                                    "$queryParam&status=failed&error=true&cause=REFRESH_TOKEN_EXPIRED"                                                )                                            }                                        }                                        override fun onFailed(responseCode: Int) {                                            destroySocket()                                            connect(                                                userId,                                                onSuccess,                                                onError,                                                isBackground,                                                true,                                                queryParam                                            )                                        }                                    },                                    object : RetryListener {                                        override fun onRetry(newToken: String) {                                            destroySocket()                                            connect(                                                userId,                                                onSuccess,                                                onError,                                                isBackground,                                                true                                            )                                        }                                    })                            }                        } else if (errorMessage.contains("AUTHENTICATION_ERROR_REFRESH_TOKEN_EXPIRED")) {                            CoroutineScope(Dispatchers.IO).launch {                                application.logout(tokenManager.getSignInMethod())                            }                        } else {                            CoroutineScope(Dispatchers.IO).launch {                                delay(1000)                                destroySocket()                                connect(                                    userId,                                    onSuccess,                                    onError,                                    isBackground,                                    true,                                    queryParam                                )                            }                        }                    } else {                        _statusFlow.value = false                        _socketFlow.value = null // Emit null when disconnected                        onError()                        Log.d(TAG, "EVENT_CONNECT_ERROR")                    }                    val errorMessage = if (args.isNotEmpty()) {                        val error = args[0]                        if (error is Exception) {                            "Connection error: ${error.message}"                        } else {                            "Connection error: $error"                        }                    } else {                        "Unknown connection error occurred."                    }                }                socket?.on(Socket.EVENT_DISCONNECT) { args ->                    // Get the reason for disconnection if available                    val reason = if (args.isNotEmpty()) args[0] else "No reason provided"                    Log.d(TAG, "EVENT_DISCONNECT $reason")                    _statusFlow.value = false                    stopHeartbeat()                    _socketFlow.value = null // Emit null when disconnected                }                socket?.on(Manager.EVENT_RECONNECT_ATTEMPT) {                    Log.d(TAG, "EVENT_RECONNECT_ATTEMPT")                }                socket?.on(Manager.EVENT_RECONNECT) {                    Log.d(TAG, "EVENT_RECONNECT")                }                socket?.on(Manager.EVENT_RECONNECT_FAILED) {                    Log.d(TAG, "EVENT_RECONNECT_FAILED")                }                socket?.on(Manager.EVENT_RECONNECT_ERROR) {                    Log.d(TAG, "EVENT_RECONNECT_ERROR")                }                // Connect the socket                socket?.connect()            } catch (e: UnknownHostException) {                Log.e(TAG, "Unknown host.", e)            } catch (e: SocketTimeoutException) {                Log.e(TAG, "Connection timed out.", e)            } catch (e: SocketException) {                Log.e(TAG, "A socket error occurred.", e)            } catch (e: IOException) {                Log.e(TAG, "An I/O error occurred while creating the socket.", e)            } catch (e: Exception) {                Log.e(TAG, "An unexpected error occurred while initializing the socket.", e)            }        }    }    private fun chatMessageProcessor(data: JSONObject, userId: Long) {        val senderId = data.getLong("sender")        val messageId = data.getLong("message_id")        val replyId = data.getLong("reply_id")        val type = data.getString("type")        val encryptedMessage = data.getString("message")        val category = data.getString("category")        val keyVersion = data.optLong("key_version") // Please check it        Log.e(TAG,"Cate")        CoroutineScope(Dispatchers.IO).launch {            val chatUser = chatUserDao.getChatUserByRecipientId(senderId)            if (chatUser == null) {                withContext(Dispatchers.Main) {                    // After cancellation, enqueue new work for fetching user profile                    ChatMessageHandlerWorkerHelper.enqueueFetchUserProfileWork(                        application,                        userId,                        senderId,                        messageId,                        data.toString()                    )                }            } else {                if (category.contains("image") || category.contains("video") || category.contains("gif")) {                    ChatMessageHandlerWorkerHelper.visualMediaChatMessageProcessor(                        application,                        data,                        chatUser.chatId,                        chatUser.recipientId,                        senderId,                        replyId,                        messageId,                        encryptedMessage                    )                } else if (category.contains("audio")) {                    // Create input data to pass the FCM token to the worker                    val fileMetadata = JSONObject(data.getString("file_metadata"))                    val originalFileName = fileMetadata.optString("original_file_name")                    val fileSize = fileMetadata.optLong("file_size")                    val contentType = fileMetadata.optString("content_type")                    val fileExtension = fileMetadata.optString("extension")                    val totalDuration = fileMetadata.optLong("total_duration")                    val downloadUrl = fileMetadata.optString("download_url")                    CoroutineScope(Dispatchers.IO)                        .launch {                            messageDao.insertMessageAndMetadata(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = encryptedMessage,                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.SENDING,                                    type = ChatMessageType.AUDIO,                                ),                                fileMetaDataDao,                                MessageMediaMetadata(                                    messageId = -1,                                    fileDownloadUrl = downloadUrl,                                    fileSize = fileSize,                                    fileMimeType = contentType,                                    fileExtension = fileExtension,                                    originalFileName = originalFileName,                                    totalDuration = totalDuration                                )                            )                        }                    socket?.emit("chat:acknowledgment", JSONObject().apply {                        put("status", "delivered")                        put("sender", senderId)                        put("recipient_id", chatUser.recipientId)                        put("message_id", messageId)                    }, Ack {                        // Handle acknowledgment from the server                        Log.d(TAG, "Acknowledgment received by client")                    })                } else if (category.contains("file")) {                    // Create input data to pass the FCM token to the worker                    val fileMetadata = JSONObject(data.getString("file_metadata"))                    val originalFileName = fileMetadata.optString("original_file_name")                    val fileSize = fileMetadata.optLong("file_size")                    val contentType = fileMetadata.optString("content_type")                    val fileExtension = fileMetadata.optString("extension")                    val downloadUrl = fileMetadata.optString("download_url")                    CoroutineScope(Dispatchers.IO)                        .launch {                            messageDao.insertMessageAndMetadata(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = encryptedMessage,                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.SENDING,                                    type = ChatMessageType.FILE,                                    ),                                fileMetaDataDao,                                MessageMediaMetadata(                                    messageId = -1,                                    fileDownloadUrl = downloadUrl,                                    fileSize = fileSize,                                    fileMimeType = contentType,                                    fileExtension = fileExtension,                                    originalFileName = originalFileName,                                )                            )                        }                    socket?.emit("chat:acknowledgment", JSONObject().apply {                        put("status", "delivered")                        put("sender", senderId)                        put("recipient_id", chatUser.recipientId)                        put(                            "message_id",                            messageId                        ) // Add the inserted message ID to JSON                    }, Ack {                        // Handle acknowledgment from the server                        Log.d(TAG, "Acknowledgment received by client")                    })                } else if (category.contains("others")) {                    // Create input data to pass the FCM token to the worker                    val fileMetadata = JSONObject(data.getString("file_metadata"))                    val originalFileName = fileMetadata.optString("original_file_name")                    val fileSize = fileMetadata.optLong("file_size")                    val contentType = fileMetadata.optString("content_type")                    val fileExtension = fileMetadata.optString("extension")                    val totalDuration = fileMetadata.optLong("total_duration")                    val downloadUrl = fileMetadata.optString("download_url")                    CoroutineScope(Dispatchers.IO)                        .launch {                            messageDao.insertMessageAndMetadata(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = encryptedMessage,                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.SENDING,                                    type = ChatMessageType.FILE                                ),                                fileMetaDataDao,                                MessageMediaMetadata(                                    messageId = -1,                                    fileDownloadUrl = downloadUrl,                                    fileSize = fileSize,                                    fileMimeType = contentType,                                    fileExtension = fileExtension,                                    originalFileName = originalFileName,                                )                            )                        }                    socket?.emit("chat:acknowledgment", JSONObject().apply {                        put("status", "delivered")                        put("sender", senderId)                        put("recipient_id", chatUser.recipientId)                        put("message_id", messageId) // Add the inserted message ID to JSON                    }, Ack {                        // Handle acknowledgment from the server                        Log.d(TAG, "Acknowledgment received by client")                    })                } else {                    when (val decryptionStatus = decryptMessage(encryptedMessage)) {                        is DecryptionStatus.DecryptionFailed -> {                            messageDao.insertMessage(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = "",                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.FAILED_TO_DISPLAY_REASON_DECRYPTION_FAILED                                )                            )                        }                        is DecryptionStatus.UnknownError -> {                            messageDao.insertMessage(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = "",                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.FAILED_TO_DISPLAY_REASON_UNKNOWN                                )                            )                        }                        is DecryptionStatus.Success -> {                            messageDao.insertMessage(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = decryptionStatus.decryptedMessage,                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.SENDING                                )                            )                        }                    }                    socket?.emit("chat:acknowledgment", JSONObject().apply {                        put("status", "delivered")                        put("sender", senderId)                        put("recipient_id", chatUser.recipientId)                        put(                            "message_id",                            messageId                        ) // Add the inserted message ID to JSON                    }, Ack {                        // Handle acknowledgment from the server                        Log.d(TAG, "Acknowledgment received by client")                    })                }            }        }    }    fun reconnect(isForceNew: Boolean = false) {        val userId = UserSharedPreferencesManager.userId        connect(userId, {}, {}, false, isForceNew)    }    // Destroy the socket connection    fun destroySocket() {        socket?.disconnect()        socket = null        _socketFlow.value = null // Emit null when socket is destroyed    }    // Coroutine scope for UI-related tasks    private var heartbeatJob: Job? = null // Job to manage heartbeat coroutine    // Start heartbeat using coroutines    private fun startHeartbeat() {        // Start the heartbeat coroutine        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {            sendHeartbeatPeriodically()        }    }    // A suspend function that sends heartbeat periodically    private suspend fun sendHeartbeatPeriodically() {        while (true) { // Check if the coroutine is still active            socket?.let {                if (it.connected()) {                    it.emit("chat:heartbeat") // Send heartbeat to the server                } else {                    stopHeartbeat()                }            } ?: run {                stopHeartbeat()            }            delay(2000) // Delay before sending the next heartbeat (2 seconds)        }    }    private fun stopHeartbeat() {        heartbeatJob?.cancel() // Cancel the heartbeat coroutine when the ViewModel is cleared    }}