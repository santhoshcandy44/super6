package com.lts360.api.auth.managers.socketimport android.content.Contextimport android.util.Logimport com.lts360.Appimport com.lts360.BuildConfigimport com.lts360.api.auth.managers.CriticalListenerimport com.lts360.api.auth.managers.RefreshTokenManagerimport com.lts360.api.auth.managers.RetryListenerimport com.lts360.api.auth.managers.TokenManagerimport com.lts360.app.database.daos.chat.ChatUserDaoimport com.lts360.app.database.daos.chat.MessageDaoimport com.lts360.app.database.daos.chat.MessageMediaMetaDataDaoimport com.lts360.app.database.models.chat.ChatMessageStatusimport com.lts360.app.database.models.chat.ChatMessageTypeimport com.lts360.app.database.models.chat.ChatUserimport com.lts360.app.database.models.chat.Messageimport com.lts360.app.database.models.chat.MessageMediaMetadataimport com.lts360.app.workers.helpers.ChatMessageHandlerWorkerHelperimport com.lts360.components.utils.LogUtils.TAGimport com.lts360.compose.ui.auth.repos.DecryptionStatusimport com.lts360.compose.ui.auth.repos.decryptMessageimport com.lts360.compose.ui.auth.repos.encryptMessageimport com.lts360.compose.ui.managers.UserSharedPreferencesManagerimport dagger.hilt.android.qualifiers.ApplicationContextimport io.socket.client.Ackimport io.socket.client.IOimport io.socket.client.Managerimport io.socket.client.Socketimport kotlinx.coroutines.CompletableDeferredimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.asStateFlowimport kotlinx.coroutines.launchimport kotlinx.coroutines.sync.Muteximport kotlinx.coroutines.sync.withLockimport kotlinx.coroutines.withContextimport kotlinx.coroutines.withTimeoutimport org.json.JSONObjectimport java.io.IOExceptionimport java.net.SocketExceptionimport java.net.SocketTimeoutExceptionimport java.net.UnknownHostExceptionimport javax.inject.Injectimport javax.inject.Singletonimport kotlin.coroutines.resumeimport kotlin.coroutines.suspendCoroutine@Singletonclass SocketManager @Inject constructor(    @ApplicationContext val context: Context,    val tokenManager: TokenManager,    val messageDao: MessageDao,    private val fileMetaDataDao: MessageMediaMetaDataDao,    val chatUserDao: ChatUserDao) {    val application = context.applicationContext as App    init {        UserSharedPreferencesManager.initialize(context.applicationContext)    }    private var socket: Socket? = null    private val _socketFlow = MutableStateFlow<Socket?>(null)    val socketFlow = _socketFlow.asStateFlow()    private val _statusFlow = MutableStateFlow(false)    val statusFlow = _statusFlow.asStateFlow()    var isBackgroundSocket = false    private var heartbeatJob: Job? = null    private val mutex = Mutex()    suspend fun initSocket(        onSuccess: (Socket) -> Unit = {},        onError: () -> Unit = {},        isBackground: Boolean = false,        isForceNew: Boolean = false,        queryParam: String = "",        from: String = "init"    ) {        mutex.withLock {            val userId = UserSharedPreferencesManager.userId            connect(                userId,                onSuccess = onSuccess,                onError = onError,                isBackground = isBackground,                isForceNew = isForceNew,                queryParam = queryParam,                from            )        }    }    suspend fun reconnect(isForceNew: Boolean = false) {        val userId = UserSharedPreferencesManager.userId        mutex.withLock {            connect(userId, {}, {}, false, isForceNew)        }    }    suspend fun getSocket(        onSuccess: (Socket) -> Unit = {},        onError: () -> Unit = {},        isBackground: Boolean = false,        isForceNew: Boolean = false,        queryParam: String = "",        from: String = "init"    ): Socket {        val userId = UserSharedPreferencesManager.userId        connect(            userId,            onSuccess = onSuccess,            onError = onError,            isBackground = isBackground,            isForceNew = isForceNew,            queryParam = queryParam,            from        )        return socket!!    }    private suspend fun connect(        userId: Long,        onSuccess: (Socket) -> Unit,        onError: () -> Unit,        isBackground: Boolean,        isForceNew: Boolean = false,        queryParam: String = "",        from: String = "init"    ) {        var socketInitializationDeferred: CompletableDeferred<Unit>?        isBackgroundSocket = isBackground        socket?.takeIf {            it.connected() &&                    !isForceNew        }?.let { nonNullSocket ->            if (!nonNullSocket.connected()) {                onError()            } else {                onSuccess(nonNullSocket)            }        } ?: run {            socketInitializationDeferred = CompletableDeferred<Unit>()            destroySocket()            try {                val accessToken = tokenManager.getAccessToken()                socket = IO.socket(BuildConfig.SOCKET_BASE_URL, IO.Options().apply {                    forceNew = true                    reconnection = true                    reconnectionAttempts = Int.MAX_VALUE                    reconnectionDelay = 1000                    reconnectionDelayMax = 1000                    query = queryParam                    auth = mapOf("token" to accessToken)                })                socket?.on(Socket.EVENT_CONNECT) {                    Log.d(TAG, "EVENT_CONNECT $from")                    startHeartbeat()                    socket?.emit("chat:userJoined", JSONObject().apply {                        put("user_id", userId)                        put("is_background", isBackground)                    })                    if (isBackground) {                        onSuccess(socket!!)                        socketInitializationDeferred.complete(Unit)                        return@on                    }                    CoroutineScope(Dispatchers.IO).launch {                        val queuedMessages = messageDao.getQueuedMessages()                        queuedMessages.forEach { queuedMessage ->                            if (socket!!.connected()) {                                if (queuedMessage.type == ChatMessageType.TEXT) {                                    val publicKeyWithVersion =                                        chatUserDao.getPublicKeyWithVersionByRecipientIdRaw(                                            queuedMessage.recipientId                                        )                                    val jsonData = JSONObject().apply {                                        put("user_id", userId)                                        put("recipient_id", queuedMessage.recipientId)                                    }                                    publicKeyWithVersion?.let {                                        try {                                            jsonData.put(                                                "message",                                                encryptMessage(                                                    queuedMessage.content,                                                    it.publicKey                                                )                                            )                                            jsonData.put("key_version", it.keyVersion)                                            jsonData.put("message_id", queuedMessage.id)                                            jsonData.put("category", "text")                                            jsonData.put(                                                "reply_id",                                                queuedMessage.senderMessageId                                            )                                            jsonData.put(                                                "type",                                                if (queuedMessage.replyId != -1L) "reply" else "normal"                                            )                                            val args = withTimeout(5_000L) {                                                suspendCoroutine<Array<Any>> { continuation ->                                                    socket!!.emit(                                                        "chat:chatMessage",                                                        jsonData,                                                        Ack { continuation.resume(it) })                                                }                                            }                                            if (args.isNotEmpty()) {                                                val response = args[0] as String                                                val data = args.getOrNull(1) as? JSONObject                                                val status = data?.optString("status")                                                when (status) {                                                    "KEY_ERROR" -> {                                                        val recipientId =                                                            data.getLong("recipient_id")                                                        val newPublicKey =                                                            data.getString("publicKey")                                                        val newKeyVersion =                                                            data.getLong("keyVersion")                                                        chatUserDao.updatePublicKeyByRecipientId(                                                            recipientId,                                                            newPublicKey,                                                            newKeyVersion                                                        )                                                        messageDao.updateMessageStatus(                                                            queuedMessage.id,                                                            ChatMessageStatus.QUEUED                                                        )                                                        val redeliverMessages =                                                            messageDao.getQueuedMessages()                                                        redeliverMessages.forEach { msg ->                                                            if (socket?.connected() == true) {                                                                try {                                                                    val resendJson =                                                                        JSONObject().apply {                                                                            put("user_id", userId)                                                                            put(                                                                                "recipient_id",                                                                                msg.recipientId                                                                            )                                                                            put(                                                                                "message",                                                                                encryptMessage(                                                                                    msg.content,                                                                                    newPublicKey                                                                                )                                                                            )                                                                            put(                                                                                "key_version",                                                                                newKeyVersion                                                                            )                                                                            put(                                                                                "message_id",                                                                                msg.id                                                                            )                                                                            put(                                                                                "reply_id",                                                                                msg.replyId                                                                            )                                                                            put(                                                                                "type",                                                                                if (msg.replyId != -1L) "reply" else "normal"                                                                            )                                                                            put("category", "text")                                                                        }                                                                    withTimeout(5_000L) {                                                                        suspendCoroutine<Unit> { continuation ->                                                                            socket!!.emit(                                                                                "chat:chatMessage",                                                                                resendJson,                                                                                Ack { ackArgs ->                                                                                    val ackStatus =                                                                                        (ackArgs.getOrNull(                                                                                            1                                                                                        ) as? JSONObject)                                                                                            ?.optString(                                                                                                "status"                                                                                            )                                                                                    val newStatus =                                                                                        when (ackStatus) {                                                                                            "KEY_ERROR", "USER_NOT_ACTIVE_ERROR" -> ChatMessageStatus.FAILED                                                                                            else -> ChatMessageStatus.SENT                                                                                        }                                                                                    CoroutineScope(                                                                                        Dispatchers.IO                                                                                    ).launch {                                                                                        messageDao.updateMessageStatus(                                                                                            msg.id,                                                                                            newStatus                                                                                        )                                                                                    }                                                                                    continuation.resume(                                                                                        Unit                                                                                    )                                                                                })                                                                        }                                                                    }                                                                } catch (e: Exception) {                                                                    e.printStackTrace()                                                                    messageDao.updateMessageStatus(                                                                        msg.id,                                                                        ChatMessageStatus.FAILED                                                                    )                                                                }                                                            }                                                        }                                                    }                                                    "USER_NOT_ACTIVE_ERROR" -> {                                                        messageDao.updateMessageStatus(                                                            queuedMessage.id,                                                            ChatMessageStatus.FAILED                                                        )                                                    }                                                    else -> {                                                        messageDao.updateMessageStatus(                                                            queuedMessage.id,                                                            ChatMessageStatus.SENT                                                        )                                                        Log.d(TAG, "Message sent & acknowledged")                                                    }                                                }                                            } else {                                                messageDao.updateMessageStatus(                                                    queuedMessage.id,                                                    ChatMessageStatus.FAILED                                                )                                            }                                        } catch (e: Exception) {                                            e.printStackTrace()                                            messageDao.updateMessageStatus(                                                queuedMessage.id,                                                ChatMessageStatus.FAILED                                            )                                        }                                    } ?: run {                                        val args = withTimeout(5_000L) {                                            suspendCoroutine<Array<Any>> { continuation ->                                                socket!!.emit(                                                    "chat:queryPublicKey",                                                    jsonData,                                                    Ack { continuation.resume(it) })                                            }                                        }                                        if (args.isNotEmpty()) {                                            val response = args[1] as JSONObject                                            val recipientId = response.getLong("recipient_id")                                            val publicKey = response.getString("publicKey")                                            val keyVersion = response.getLong("keyVersion")                                            chatUserDao.updatePublicKeyByRecipientId(                                                recipientId,                                                publicKey,                                                keyVersion                                            )                                            messageDao.updateMessageStatus(                                                queuedMessage.id,                                                ChatMessageStatus.QUEUED                                            )                                            val queuedMessages = messageDao.getQueuedMessages()                                            queuedMessages.forEach { msg ->                                                if (socket!!.connected()) {                                                    try {                                                        val messageJson = JSONObject().apply {                                                            put("user_id", userId)                                                            put("recipient_id", msg.recipientId)                                                            put(                                                                "message",                                                                encryptMessage(                                                                    msg.content,                                                                    publicKey                                                                )                                                            )                                                            put("key_version", keyVersion)                                                            put("message_id", msg.id)                                                            put("reply_id", msg.replyId)                                                            put(                                                                "type",                                                                if (msg.replyId != -1L) "reply" else "normal"                                                            )                                                            put("category", "text")                                                        }                                                        withTimeout(5_000L) {                                                            suspendCoroutine<Unit> { continuation ->                                                                socket!!.emit(                                                                    "chat:chatMessage",                                                                    messageJson,                                                                    Ack { ackArgs ->                                                                        if (ackArgs.isNotEmpty()) {                                                                            CoroutineScope(                                                                                Dispatchers.IO                                                                            ).launch {                                                                                messageDao.updateMessageStatus(                                                                                    msg.id,                                                                                    ChatMessageStatus.SENT                                                                                )                                                                            }                                                                            Log.d(                                                                                TAG,                                                                                "Queued message acknowledged by server"                                                                            )                                                                        }                                                                        continuation.resume(Unit)                                                                    })                                                            }                                                        }                                                    } catch (e: Exception) {                                                        messageDao.updateMessageStatus(                                                            msg.id,                                                            ChatMessageStatus.FAILED                                                        )                                                        e.printStackTrace()                                                    }                                                }                                            }                                        } else {                                            messageDao.updateMessageStatus(                                                queuedMessage.id,                                                ChatMessageStatus.FAILED                                            )                                        }                                    }                                }                            }                        }                    }                    _statusFlow.value = true                    _socketFlow.value = socket                    onSuccess(socket!!)                    socketInitializationDeferred.complete(Unit)                }                if (!isBackground) {                    socket?.on("chat:offlineMessages") { args ->                        val data = args[0] as JSONObject                        val ack = args[1] as? Ack                        val senderId = data.getLong("sender_id")                        CoroutineScope(Dispatchers.IO).launch {                            chatUserDao.getChatUserByRecipientId(senderId)                                ?.let {                                    ack?.call(JSONObject().apply {                                        put("success", true)                                    })                                    chatMessageProcessor(it, data)                                } ?: run {                                ack?.call(JSONObject().apply {                                    put("success", false)                                    put("error", "NO_PROFILE_ERROR")                                })                            }                        }                    }                    socket?.on("chat:messageStatus") { args ->                        val data = args[0] as JSONObject                        val senderId = data.getInt("sender_id")                        val recipientId = data.getInt("recipient_id")                        val messageId = data.getLong("message_id")                        val status = data.getString("status")                        CoroutineScope(Dispatchers.IO).launch {                            when (status) {                                "delivered" -> {                                    messageDao.updateMessageStatus(                                        messageId,                                        ChatMessageStatus.DELIVERED                                    )                                }                                "sent" -> {                                    messageDao.updateMessageStatus(                                        messageId,                                        ChatMessageStatus.SENT                                    )                                }                                else -> {                                    messageDao.updateMessageStatus(                                        messageId,                                        ChatMessageStatus.FAILED                                    )                                }                            }                            (args[1] as? Ack)?.call(JSONObject().apply {                                put("success", true)                                put("sender_id", senderId)                                put("message_id", messageId)                            })                        }                    }                    socket?.on("chat:profileFetch") { args ->                        val data = args[0] as JSONObject                        val senderId = data.getLong("sender_id")                        val type = data.getString("type")                        CoroutineScope(Dispatchers.IO).launch {                            withContext(Dispatchers.Main) {                                ChatMessageHandlerWorkerHelper.enqueueFetchUserProfileWork(                                    application,                                    userId,                                    senderId,                                    type,                                    data.toString()                                )                            }                        }                    }                    socket?.on("chat:chatMessage") { args ->                        val data = args[0] as JSONObject                        val ack = args[1] as? Ack                        val senderId = data.getLong("sender_id")                        CoroutineScope(Dispatchers.IO).launch {                            chatUserDao.getChatUserByRecipientId(senderId)                                ?.let {                                    ack?.call(JSONObject().apply {                                        put("success", true)                                    })                                    chatMessageProcessor(it, data)                                } ?: run {                                ack?.call(JSONObject().apply {                                    put("success", false)                                    put("error", "NO_PROFILE_ERROR")                                })                            }                        }                    }                    socket?.on("chat:check") { args ->                        (args[1] as? Ack)?.call()                    }                }                socket?.on(Socket.EVENT_CONNECT_ERROR) { args ->                    if (args[0] is JSONObject) {                        destroySocket()                        val error = args[0] as JSONObject                        val errorMessage = error.optString("message")                        if (errorMessage.contains("AUTHENTICATION_ERROR_NO_TOKEN_PROVIDED")                            || errorMessage.contains("AUTHENTICATION_ERROR_INVALID_TOKEN")                        ) {                            CoroutineScope(Dispatchers.IO).launch {                                delay(1000)                                connect(                                    userId,                                    onSuccess,                                    onError,                                    isBackground,                                    true,                                    queryParam                                )                                socketInitializationDeferred.complete(Unit)                            }                        } else if (errorMessage.contains("AUTHENTICATION_ERROR_TOKEN_EXPIRED")) {                            CoroutineScope(Dispatchers.IO).launch {                                RefreshTokenManager.onRefreshAccessToken(                                    tokenManager,                                    accessToken,                                    object : CriticalListener {                                        override fun onSuccess(newToken: String) {                                            destroySocket()                                            CoroutineScope(Dispatchers.IO).launch {                                                connect(                                                    userId,                                                    onSuccess,                                                    onError,                                                    isBackground,                                                    true,                                                    queryParam,                                                    from = "Refresh success"                                                )                                                socketInitializationDeferred.complete(Unit)                                            }                                        }                                        override fun onError(e: Exception?) {                                            if (e != null) {                                                e.printStackTrace()                                            } else {                                                destroySocket()                                                CoroutineScope(Dispatchers.IO).launch {                                                    connect(                                                        userId,                                                        onSuccess,                                                        onError,                                                        isBackground,                                                        true,                                                        "$queryParam&status=failed&error=true&cause=REFRESH_TOKEN_EXPIRED",                                                        from = "Refresh error"                                                    )                                                    socketInitializationDeferred.complete(Unit)                                                }                                            }                                        }                                        override fun onFailed(responseCode: Int) {                                            destroySocket()                                            CoroutineScope(Dispatchers.IO).launch {                                                connect(                                                    userId,                                                    onSuccess,                                                    onError,                                                    isBackground,                                                    true,                                                    queryParam,                                                    from = "Refresh failed"                                                )                                                socketInitializationDeferred.complete(Unit)                                            }                                        }                                    },                                    object : RetryListener {                                        override fun onRetry(newToken: String) {                                            destroySocket()                                            CoroutineScope(Dispatchers.IO).launch {                                                connect(                                                    userId,                                                    onSuccess,                                                    onError,                                                    isBackground,                                                    true,                                                    from = "Refresh retry"                                                )                                                socketInitializationDeferred.complete(Unit)                                            }                                        }                                    })                            }                        } else if (errorMessage.contains("AUTHENTICATION_ERROR_REFRESH_TOKEN_EXPIRED")) {                            CoroutineScope(Dispatchers.IO).launch {                                application.logout(tokenManager.getSignInMethod())                                socketInitializationDeferred.complete(Unit)                            }                        } else {                            CoroutineScope(Dispatchers.IO).launch {                                delay(1000)                                destroySocket()                                connect(                                    userId,                                    onSuccess,                                    onError,                                    isBackground,                                    true,                                    queryParam                                )                                socketInitializationDeferred.complete(Unit)                            }                        }                    } else {                        _statusFlow.value = false                        _socketFlow.value = null                        onError()                        socketInitializationDeferred.complete(Unit)                        Log.d(TAG, "EVENT_CONNECT_ERROR")                    }                }                socket?.on(Socket.EVENT_DISCONNECT) { args ->                    val reason = if (args.isNotEmpty()) args[0] else "No reason provided"                    Log.d(TAG, "EVENT_DISCONNECT $reason")                    _statusFlow.value = false                    stopHeartbeat()                    _socketFlow.value = null                    socketInitializationDeferred.complete(Unit)                }                socket?.on(Manager.EVENT_RECONNECT_ATTEMPT) {                    Log.d(TAG, "EVENT_RECONNECT_ATTEMPT")                }                socket?.on(Manager.EVENT_RECONNECT) {                    Log.d(TAG, "EVENT_RECONNECT")                }                socket?.on(Manager.EVENT_RECONNECT_FAILED) {                    Log.d(TAG, "EVENT_RECONNECT_FAILED")                }                socket?.on(Manager.EVENT_RECONNECT_ERROR) {                    Log.d(TAG, "EVENT_RECONNECT_ERROR")                }                socket?.connect()            } catch (e: UnknownHostException) {                Log.e(TAG, "Unknown host.", e)            } catch (e: SocketTimeoutException) {                Log.e(TAG, "Connection timed out.", e)            } catch (e: SocketException) {                Log.e(TAG, "A socket error occurred.", e)            } catch (e: IOException) {                Log.e(TAG, "An I/O error occurred while creating the socket.", e)            } catch (e: Exception) {                Log.e(TAG, "An unexpected error occurred while initializing the socket.", e)            }            socketInitializationDeferred.takeIf { !it.isCompleted }?.await()        }    }    private fun startHeartbeat() {        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {            sendHeartbeatPeriodically()        }    }    private suspend fun sendHeartbeatPeriodically() {        while (true) {            socket?.let {                if (it.connected()) {                    it.emit("chat:heartbeat")                } else {                    stopHeartbeat()                }            } ?: run {                stopHeartbeat()            }            delay(2000)        }    }    private fun stopHeartbeat() {        heartbeatJob?.cancel()    }    fun destroySocket() {        socket?.disconnect()        socket = null        _socketFlow.value = null    }    private suspend fun chatMessageProcessor(chatUser: ChatUser, data: JSONObject) {        val senderId = data.getLong("sender_id")        val messageId = data.getLong("message_id")        val replyId = data.getLong("reply_id")        val type = data.getString("type")        val encryptedMessage = data.getString("message")        val category = data.getString("category")        val keyVersion = data.optLong("key_version")        if (category.contains("image") || category.contains("video") || category.contains("gif")) {            ChatMessageHandlerWorkerHelper.visualMediaChatMessageProcessor(                application,                data,                chatUser.chatId,                chatUser.recipientId,                senderId,                replyId,                messageId,                encryptedMessage            )        } else if (category.contains("audio")) {            val fileMetadata = JSONObject(data.getString("file_metadata"))            val originalFileName = fileMetadata.optString("original_file_name")            val fileSize = fileMetadata.optLong("file_size")            val contentType = fileMetadata.optString("content_type")            val fileExtension = fileMetadata.optString("extension")            val totalDuration = fileMetadata.optLong("total_duration")            val downloadUrl = fileMetadata.optString("download_url")            CoroutineScope(Dispatchers.IO)                .launch {                    messageDao.insertMessageAndMetadata(                        Message(                            chatId = chatUser.chatId,                            senderId = senderId,                            recipientId = chatUser.userId,                            content = encryptedMessage,                            timestamp = System.currentTimeMillis(),                            senderMessageId = messageId,                            replyId = replyId,                            status = ChatMessageStatus.SENDING,                            type = ChatMessageType.AUDIO,                        ),                        fileMetaDataDao,                        MessageMediaMetadata(                            messageId = -1,                            fileDownloadUrl = downloadUrl,                            fileSize = fileSize,                            fileMimeType = contentType,                            fileExtension = fileExtension,                            originalFileName = originalFileName,                            totalDuration = totalDuration                        )                    )                }            socket?.emit("chat:acknowledgment", JSONObject().apply {                put("status", "delivered")                put("sender", senderId)                put("recipient_id", chatUser.recipientId)                put("message_id", messageId)            }, Ack {                Log.d(TAG, "Acknowledgment received by client")            })        } else if (category.contains("file")) {            val fileMetadata = JSONObject(data.getString("file_metadata"))            val originalFileName = fileMetadata.optString("original_file_name")            val fileSize = fileMetadata.optLong("file_size")            val contentType = fileMetadata.optString("content_type")            val fileExtension = fileMetadata.optString("extension")            val downloadUrl = fileMetadata.optString("download_url")            CoroutineScope(Dispatchers.IO)                .launch {                    messageDao.insertMessageAndMetadata(                        Message(                            chatId = chatUser.chatId,                            senderId = senderId,                            recipientId = chatUser.userId,                            content = encryptedMessage,                            timestamp = System.currentTimeMillis(),                            senderMessageId = messageId,                            replyId = replyId,                            status = ChatMessageStatus.SENDING,                            type = ChatMessageType.FILE,                            ),                        fileMetaDataDao,                        MessageMediaMetadata(                            messageId = -1,                            fileDownloadUrl = downloadUrl,                            fileSize = fileSize,                            fileMimeType = contentType,                            fileExtension = fileExtension,                            originalFileName = originalFileName,                        )                    )                }            socket?.emit("chat:acknowledgment", JSONObject().apply {                put("status", "delivered")                put("sender", senderId)                put("recipient_id", chatUser.recipientId)                put("message_id", messageId)            }, Ack {                Log.d(TAG, "Acknowledgment received by client")            })        } else if (category.contains("others")) {            val fileMetadata = JSONObject(data.getString("file_metadata"))            val originalFileName = fileMetadata.optString("original_file_name")            val fileSize = fileMetadata.optLong("file_size")            val contentType = fileMetadata.optString("content_type")            val fileExtension = fileMetadata.optString("extension")            val totalDuration = fileMetadata.optLong("total_duration")            val downloadUrl = fileMetadata.optString("download_url")            CoroutineScope(Dispatchers.IO)                .launch {                    messageDao.insertMessageAndMetadata(                        Message(                            chatId = chatUser.chatId,                            senderId = senderId,                            recipientId = chatUser.userId,                            content = encryptedMessage,                            timestamp = System.currentTimeMillis(),                            senderMessageId = messageId,                            replyId = replyId,                            status = ChatMessageStatus.SENDING,                            type = ChatMessageType.FILE                        ),                        fileMetaDataDao,                        MessageMediaMetadata(                            messageId = -1,                            fileDownloadUrl = downloadUrl,                            fileSize = fileSize,                            fileMimeType = contentType,                            fileExtension = fileExtension,                            originalFileName = originalFileName,                        )                    )                }            socket?.emit("chat:acknowledgment", JSONObject().apply {                put("status", "delivered")                put("sender", senderId)                put("recipient_id", chatUser.recipientId)                put("message_id", messageId)            }, Ack {                Log.d(TAG, "Acknowledgment received by client")            })        } else {            when (val decryptionStatus = decryptMessage(encryptedMessage)) {                is DecryptionStatus.DecryptionFailed -> {                    messageDao.insertMessage(                        Message(                            chatId = chatUser.chatId,                            senderId = senderId,                            recipientId = chatUser.userId,                            content = "",                            timestamp = System.currentTimeMillis(),                            senderMessageId = messageId,                            replyId = replyId,                            status = ChatMessageStatus.FAILED_TO_DISPLAY_REASON_DECRYPTION_FAILED                        )                    )                }                is DecryptionStatus.UnknownError -> {                    messageDao.insertMessage(                        Message(                            chatId = chatUser.chatId,                            senderId = senderId,                            recipientId = chatUser.userId,                            content = "",                            timestamp = System.currentTimeMillis(),                            senderMessageId = messageId,                            replyId = replyId,                            status = ChatMessageStatus.FAILED_TO_DISPLAY_REASON_UNKNOWN                        )                    )                }                is DecryptionStatus.Success -> {                    messageDao.insertMessage(                        Message(                            chatId = chatUser.chatId,                            senderId = senderId,                            recipientId = chatUser.userId,                            content = decryptionStatus.decryptedMessage,                            timestamp = System.currentTimeMillis(),                            senderMessageId = messageId,                            replyId = replyId,                            status = ChatMessageStatus.SENDING                        )                    )                }            }            socket?.emit("chat:acknowledgment", JSONObject().apply {                put("status", "delivered")                put("sender_id", senderId)                put("recipient_id", chatUser.recipientId)                put("message_id", messageId)            }, Ack {                Log.d(TAG, "Acknowledgment received by client")            })        }    }}