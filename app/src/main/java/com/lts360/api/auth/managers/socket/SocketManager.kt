package com.lts360.api.auth.managers.socketimport android.content.Contextimport android.util.Logimport com.lts360.Appimport com.lts360.BuildConfigimport com.lts360.api.auth.managers.CriticalListenerimport com.lts360.api.auth.managers.RefreshTokenManagerimport com.lts360.api.auth.managers.RetryListenerimport com.lts360.api.auth.managers.TokenManagerimport com.lts360.app.database.daos.chat.ChatUserDaoimport com.lts360.app.database.daos.chat.MessageDaoimport com.lts360.app.database.daos.chat.MessageMediaMetaDataDaoimport com.lts360.app.database.models.chat.ChatMessageStatusimport com.lts360.app.database.models.chat.ChatMessageTypeimport com.lts360.app.database.models.chat.Messageimport com.lts360.app.database.models.chat.MessageMediaMetadataimport com.lts360.app.workers.helpers.ChatMessageHandlerWorkerHelperimport com.lts360.components.utils.LogUtils.TAGimport com.lts360.compose.ui.auth.repos.DecryptionStatusimport com.lts360.compose.ui.auth.repos.decryptMessageimport com.lts360.compose.ui.auth.repos.encryptMessageimport com.lts360.compose.ui.managers.UserSharedPreferencesManagerimport dagger.hilt.android.qualifiers.ApplicationContextimport io.socket.client.Ackimport io.socket.client.IOimport io.socket.client.Managerimport io.socket.client.Socketimport kotlinx.coroutines.CompletableDeferredimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.asStateFlowimport kotlinx.coroutines.launchimport kotlinx.coroutines.sync.Muteximport kotlinx.coroutines.sync.withLockimport kotlinx.coroutines.withContextimport org.json.JSONObjectimport java.io.IOExceptionimport java.net.SocketExceptionimport java.net.SocketTimeoutExceptionimport java.net.UnknownHostExceptionimport javax.inject.Injectimport javax.inject.Singleton@Singletonclass SocketManager @Inject constructor(    @ApplicationContext val context: Context,    val tokenManager: TokenManager,    val messageDao: MessageDao,    private val fileMetaDataDao: MessageMediaMetaDataDao,    val chatUserDao: ChatUserDao) {    val application = context.applicationContext as App    init {        UserSharedPreferencesManager.initialize(context.applicationContext)    }    private var socket: Socket? = null    private val _socketFlow = MutableStateFlow<Socket?>(null)    val socketFlow = _socketFlow.asStateFlow()    private val _statusFlow = MutableStateFlow(false)    val statusFlow = _statusFlow.asStateFlow()    var isBackgroundSocket = false    private var heartbeatJob: Job? = null    private val mutex = Mutex()    suspend fun initSocket(        onSuccess: (Socket) -> Unit = {},        onError: () -> Unit = {},        isBackground: Boolean = false,        isForceNew: Boolean = false,        queryParam: String = "",        from: String = "init"    ) {        mutex.withLock {            val userId = UserSharedPreferencesManager.userId            connect(                userId,                onSuccess = onSuccess,                onError = onError,                isBackground = isBackground,                isForceNew = isForceNew,                queryParam = queryParam,                from            )        }    }    suspend fun reconnect(isForceNew: Boolean = false) {        val userId = UserSharedPreferencesManager.userId        mutex.withLock {            connect(userId, {}, {}, false, isForceNew)        }    }    suspend fun getSocket(        onSuccess: (Socket) -> Unit = {},        onError: () -> Unit = {},        isBackground: Boolean = false,        isForceNew: Boolean = false,        queryParam: String = "",        from: String = "init"    ): Socket {        val userId = UserSharedPreferencesManager.userId        connect(            userId,            onSuccess = onSuccess,            onError = onError,            isBackground = isBackground,            isForceNew = isForceNew,            queryParam = queryParam,            from        )        return socket!!    }    private suspend fun connect(        userId: Long,        onSuccess: (Socket) -> Unit,        onError: () -> Unit,        isBackground: Boolean,        isForceNew: Boolean = false,        queryParam: String = "",        from: String = "init"    ) {        var socketInitializationDeferred: CompletableDeferred<Unit>?        isBackgroundSocket = isBackground        socket?.takeIf {            it.connected() &&                    !isForceNew        }?.let { nonNullSocket ->            if (!nonNullSocket.connected()) {                onError()            } else {                onSuccess(nonNullSocket)            }        } ?: run {            socketInitializationDeferred = CompletableDeferred<Unit>()            destroySocket()            try {                val accessToken = tokenManager.getAccessToken()                socket = IO.socket(BuildConfig.SOCKET_BASE_URL, IO.Options().apply {                    forceNew = true                    reconnection = true // Enable reconnection                    reconnectionAttempts = Int.MAX_VALUE // Unlimited reconnection attempts                    reconnectionDelay = 1000 // Initial reconnection delay in milliseconds                    reconnectionDelayMax = 1000 // Maximum delay for reconnection                    query = queryParam// Replace with your query parameters                    auth = mapOf("token" to accessToken) // Replace with your actual token                })                // Socket event listeners                socket?.on(Socket.EVENT_CONNECT) {                    Log.d(TAG, "EVENT_CONNECT $from")                    startHeartbeat()                    socket?.emit("chat:userJoined", JSONObject().apply {                        put("user_id", userId)                        put("is_background", isBackground)                    })                    if (isBackground) {                        onSuccess(socket!!)                        socketInitializationDeferred?.complete(Unit)                        return@on                    }                    CoroutineScope(Dispatchers.IO).launch {                        val queuedMessages = messageDao.getQueuedMessages()                        queuedMessages.forEach { queuedMessage ->                            if (socket!!.connected()) {                                if (queuedMessage.type == ChatMessageType.TEXT) {                                    val jsonData = JSONObject().apply {                                        put("user_id", userId)                                        put("recipient_id", queuedMessage.recipientId)                                    }                                    val publicKeyWithVersion =                                        chatUserDao.getPublicKeyWithVersionByRecipientIdRaw(                                            queuedMessage.recipientId                                        )                                    publicKeyWithVersion?.let {                                        try {                                            jsonData.put(                                                "message",                                                encryptMessage(                                                    queuedMessage.content,                                                    it.publicKey                                                )                                            )                                            jsonData.put("key_version", it.keyVersion)                                            jsonData.put("message_id", queuedMessage.id)                                            jsonData.put("category", "text")                                            jsonData.put(                                                "reply_id",                                                queuedMessage.senderMessageId                                            )                                            jsonData.put(                                                "type",                                                if (queuedMessage.replyId != -1L) "reply" else "normal"                                            )                                            // Emit the chat message with an acknowledgment callback                                            socket!!.emit("chat:chatMessage",                                                jsonData,                                                Ack { args ->                                                    // Handle the acknowledgment from the server                                                    if (args.isNotEmpty()) {                                                        val response = args[0] as String                                                        val data = args[1] as? JSONObject                                                        val status = data?.optString("status")                                                        if (status != null && status == "KEY_ERROR") {                                                            val recipientId =                                                                data.getLong("recipient_id")                                                            val publicKey =                                                                data.getString("publicKey")                                                            val keyVersion =                                                                data.getLong("keyVersion")                                                            chatUserDao.updatePublicKeyByRecipientId(                                                                recipientId,                                                                publicKey,                                                                keyVersion                                                            )                                                            CoroutineScope(Dispatchers.IO).launch {                                                                messageDao.updateMessageStatus(                                                                    queuedMessage.id,                                                                    ChatMessageStatus.QUEUED                                                                )                                                                val queuedMessagesRedeliver =                                                                    messageDao.getQueuedMessages()                                                                queuedMessagesRedeliver.forEach { queuedMessageRedeliver ->                                                                    if (socket!!.connected()) {                                                                        try {                                                                            val queuedData =                                                                                JSONObject().apply {                                                                                    put(                                                                                        "user_id",                                                                                        userId                                                                                    )                                                                                    put(                                                                                        "recipient_id",                                                                                        queuedMessageRedeliver.recipientId                                                                                    )                                                                                    put(                                                                                        "message",                                                                                        encryptMessage(                                                                                            queuedMessageRedeliver.content,                                                                                            publicKey                                                                                        )                                                                                    )                                                                                    put(                                                                                        "key_version",                                                                                        keyVersion                                                                                    )                                                                                    put(                                                                                        "message_id",                                                                                        queuedMessageRedeliver.id                                                                                    )                                                                                    put(                                                                                        "reply_id",                                                                                        queuedMessageRedeliver.replyId                                                                                    )                                                                                    put(                                                                                        "type",                                                                                        if (queuedMessageRedeliver.replyId != -1L) "reply" else "normal"                                                                                    )                                                                                    put(                                                                                        "category",                                                                                        "text"                                                                                    )                                                                                }                                                                            socket!!.emit(                                                                                "chat:chatMessage",                                                                                queuedData,                                                                                Ack { args ->                                                                                    // Handle the acknowledgment from the server                                                                                    if (args.isNotEmpty()) {                                                                                        val queuedResponse =                                                                                            args[0] as String                                                                                        val queuedReceivedData =                                                                                            args[1] as? JSONObject                                                                                        val queuedStatus =                                                                                            queuedReceivedData?.optString(                                                                                                "status"                                                                                            )                                                                                        if (queuedStatus != null && queuedStatus == "KEY_ERROR") {                                                                                            CoroutineScope(                                                                                                Dispatchers.IO                                                                                            ).launch {                                                                                                messageDao.updateMessageStatus(                                                                                                    queuedMessageRedeliver.id,                                                                                                    ChatMessageStatus.FAILED                                                                                                )                                                                                            }                                                                                        } else if (queuedStatus != null && queuedStatus == "USER_NOT_ACTIVE_ERROR") {                                                                                            CoroutineScope(                                                                                                Dispatchers.IO                                                                                            ).launch {                                                                                                messageDao.updateMessageStatus(                                                                                                    queuedMessageRedeliver.id,                                                                                                    ChatMessageStatus.FAILED                                                                                                )                                                                                            }                                                                                        } else {                                                                                            CoroutineScope(                                                                                                Dispatchers.IO                                                                                            ).launch {                                                                                                messageDao.updateMessageStatus(                                                                                                    queuedMessageRedeliver.id,                                                                                                    ChatMessageStatus.SENT                                                                                                )                                                                                            }                                                                                        }                                                                                        Log.d(                                                                                            TAG,                                                                                            "Queued message delivered acknowledged by server"                                                                                        )                                                                                    }                                                                                })                                                                        } catch (e: Exception) {                                                                            e.printStackTrace()                                                                            messageDao.updateMessageStatus(                                                                                queuedMessageRedeliver.id,                                                                                ChatMessageStatus.FAILED                                                                            )                                                                        }                                                                    }                                                                }                                                            }                                                        } else if (status != null && status == "USER_NOT_ACTIVE_ERROR") {                                                            CoroutineScope(Dispatchers.IO).launch {                                                                messageDao.updateMessageStatus(                                                                    queuedMessage.id,                                                                    ChatMessageStatus.FAILED                                                                )                                                            }                                                        } else {                                                            CoroutineScope(Dispatchers.IO).launch {                                                                messageDao.updateMessageStatus(                                                                    queuedMessage.id,                                                                    ChatMessageStatus.SENT                                                                )                                                            }                                                            Log.e(                                                                TAG,                                                                "Message sent & acknowledged"                                                            )                                                        }                                                    }                                                })                                        } catch (e: Exception) {                                            e.printStackTrace()                                            messageDao.updateMessageStatus(                                                queuedMessage.id,                                                ChatMessageStatus.FAILED                                            )                                        }                                    } ?: run {                                        socket!!.emit(                                            "chat:queryPublicKey",                                            jsonData,                                            Ack { args ->                                                // Handle the acknowledgment from the server                                                if (args.isNotEmpty()) {                                                    //val message = args[0] as String                                                    val response = args[1] as JSONObject                                                    val recipientId =                                                        response.getLong("recipient_id")                                                    val publicKey =                                                        response.getString("publicKey")                                                    val keyVersion =                                                        response.getLong("keyVersion")                                                    chatUserDao.updatePublicKeyByRecipientId(                                                        recipientId,                                                        publicKey,                                                        keyVersion                                                    )                                                    CoroutineScope(Dispatchers.IO)                                                        .launch {                                                            messageDao.updateMessageStatus(                                                                queuedMessage.id,                                                                ChatMessageStatus.QUEUED                                                            )                                                            val queuedMessages2 =                                                                messageDao.getQueuedMessages()                                                            queuedMessages2.forEach {                                                                if (socket!!.connected()) {                                                                    try {                                                                        val queuedData =                                                                            JSONObject().apply {                                                                                put(                                                                                    "user_id",                                                                                    userId                                                                                )                                                                                put(                                                                                    "recipient_id",                                                                                    it.recipientId                                                                                )                                                                                put(                                                                                    "message",                                                                                    encryptMessage(                                                                                        it.content,                                                                                        publicKey                                                                                    )                                                                                )                                                                                put(                                                                                    "key_version",                                                                                    keyVersion                                                                                )                                                                                put(                                                                                    "message_id",                                                                                    it.id                                                                                )                                                                                put(                                                                                    "reply_id",                                                                                    it.replyId                                                                                )                                                                                put(                                                                                    "type",                                                                                    if (it.replyId != -1L) "reply" else "normal"                                                                                )                                                                                put(                                                                                    "category",                                                                                    "text"                                                                                )                                                                            }                                                                        socket!!.emit(                                                                            "chat:chatMessage",                                                                            queuedData,                                                                            Ack { args ->                                                                                // Handle the acknowledgment from the server                                                                                if (args.isNotEmpty()) {                                                                                    val queuedResponse =                                                                                        args[0] as String                                                                                    CoroutineScope(                                                                                        Dispatchers.IO                                                                                    )                                                                                        .launch {                                                                                            messageDao.updateMessageStatus(                                                                                                it.id,                                                                                                ChatMessageStatus.SENT                                                                                            )                                                                                        }                                                                                    Log.e(                                                                                        TAG,                                                                                        "Queued message delivered & acknowledged"                                                                                    )                                                                                }                                                                            })                                                                    } catch (e: Exception) {                                                                        messageDao.updateMessageStatus(                                                                            it.id,                                                                            ChatMessageStatus.FAILED                                                                        )                                                                        e.printStackTrace()                                                                    }                                                                }                                                            }                                                        }                                                } else {                                                    CoroutineScope(Dispatchers.IO)                                                        .launch {                                                            messageDao.updateMessageStatus(                                                                queuedMessage.id,                                                                ChatMessageStatus.FAILED                                                            )                                                        }                                                }                                            })                                    }                                }                            }                        }                    }                    _statusFlow.value = true                    _socketFlow.value = socket // Emit new socket on connection                    onSuccess(socket!!)                    socketInitializationDeferred?.complete(Unit)                }                if (!isBackground) {                    socket?.on("chat:offlineMessages") { args ->                        val data = args[0] as JSONObject                        chatMessageProcessor(data, userId)                    }                    socket?.on("chat:messageStatus") { args ->                        val data = args[0] as JSONObject                        val sender = data.getInt("sender")                        val recipientId = data.getInt("recipient_id")                        val messageId = data.getLong("message_id")                        val status = data.getString("status")                        CoroutineScope(Dispatchers.IO).launch {                            when (status) {                                "delivered" -> {                                    messageDao.updateMessageStatus(                                        messageId,                                        ChatMessageStatus.DELIVERED                                    )                                }                                "sent" -> {                                    messageDao.updateMessageStatus(                                        messageId,                                        ChatMessageStatus.SENT                                    )                                }                                else -> {                                    messageDao.updateMessageStatus(                                        messageId,                                        ChatMessageStatus.FAILED                                    )                                }                            }                            // Send acknowledgment back to the server                            val acknowledgment = JSONObject().apply {                                put("success", true) // Indicate acknowledgment success                                put("sender", sender) // Include the message ID for reference                                put(                                    "message_id",                                    messageId                                ) // Include the message ID for reference                            }                            // Check if an acknowledgment callback is provided and call it                            (args[1] as? Ack)?.call(acknowledgment)                        }                    }                    socket?.on("chat:chatMessage") { args ->                        val data = args[0] as JSONObject                        chatMessageProcessor(data, userId)                    }                    socket?.on("chat:check") { args ->                        val callback = args[1] as Ack                        callback.call()                    }                }                socket?.on(Socket.EVENT_CONNECT_ERROR) { args ->                    if (args[0] is JSONObject) {                        destroySocket()                        val error = args[0] as JSONObject                        val errorMessage = error.optString("message") // Get the error message                        //Handle specific error message                        if (errorMessage.contains("AUTHENTICATION_ERROR_NO_TOKEN_PROVIDED")                            || errorMessage.contains("AUTHENTICATION_ERROR_INVALID_TOKEN")                        ) {                            CoroutineScope(Dispatchers.IO).launch {                                delay(1000)                                connect(                                    userId,                                    onSuccess,                                    onError,                                    isBackground,                                    true,                                    queryParam                                )                                socketInitializationDeferred?.complete(Unit)                            }                        } else if (errorMessage.contains("AUTHENTICATION_ERROR_TOKEN_EXPIRED")) {                            CoroutineScope(Dispatchers.IO).launch {                                RefreshTokenManager.onRefreshAccessToken(                                    tokenManager,                                    accessToken,                                    object : CriticalListener {                                        override fun onSuccess(newToken: String) {                                            destroySocket()                                            CoroutineScope(Dispatchers.IO).launch {                                                connect(                                                    userId,                                                    onSuccess,                                                    onError,                                                    isBackground,                                                    true,                                                    queryParam,                                                    from = "Refresh success"                                                )                                                socketInitializationDeferred?.complete(Unit)                                            }                                        }                                        override fun onError(e: Exception?) {                                            if (e != null) {                                                e.printStackTrace()                                            } else {                                                destroySocket()                                                CoroutineScope(Dispatchers.IO).launch {                                                    connect(                                                        userId,                                                        onSuccess,                                                        onError,                                                        isBackground,                                                        true,                                                        "$queryParam&status=failed&error=true&cause=REFRESH_TOKEN_EXPIRED",                                                        from = "Refresh error"                                                    )                                                    socketInitializationDeferred?.complete(Unit)                                                }                                            }                                        }                                        override fun onFailed(responseCode: Int) {                                            destroySocket()                                            CoroutineScope(Dispatchers.IO).launch {                                                connect(                                                    userId,                                                    onSuccess,                                                    onError,                                                    isBackground,                                                    true,                                                    queryParam,                                                    from = "Refresh failed"                                                )                                                socketInitializationDeferred?.complete(Unit)                                            }                                        }                                    },                                    object : RetryListener {                                        override fun onRetry(newToken: String) {                                            destroySocket()                                            CoroutineScope(Dispatchers.IO).launch {                                                connect(                                                    userId,                                                    onSuccess,                                                    onError,                                                    isBackground,                                                    true,                                                    from = "Refresh retry"                                                )                                                socketInitializationDeferred?.complete(Unit)                                            }                                        }                                    })                            }                        } else if (errorMessage.contains("AUTHENTICATION_ERROR_REFRESH_TOKEN_EXPIRED")) {                            CoroutineScope(Dispatchers.IO).launch {                                application.logout(tokenManager.getSignInMethod())                                socketInitializationDeferred?.complete(Unit)                            }                        } else {                            CoroutineScope(Dispatchers.IO).launch {                                delay(1000)                                destroySocket()                                connect(                                    userId,                                    onSuccess,                                    onError,                                    isBackground,                                    true,                                    queryParam                                )                                socketInitializationDeferred?.complete(Unit)                            }                        }                    } else {                        _statusFlow.value = false                        _socketFlow.value = null // Emit null when disconnected                        onError()                        socketInitializationDeferred?.complete(Unit)                        Log.d(TAG, "EVENT_CONNECT_ERROR")                    }                }                socket?.on(Socket.EVENT_DISCONNECT) { args ->                    // Get the reason for disconnection if available                    val reason = if (args.isNotEmpty()) args[0] else "No reason provided"                    Log.d(TAG, "EVENT_DISCONNECT $reason")                    _statusFlow.value = false                    stopHeartbeat()                    _socketFlow.value = null // Emit null when disconnected                    socketInitializationDeferred?.complete(Unit)                }                socket?.on(Manager.EVENT_RECONNECT_ATTEMPT) {                    Log.d(TAG, "EVENT_RECONNECT_ATTEMPT")                }                socket?.on(Manager.EVENT_RECONNECT) {                    Log.d(TAG, "EVENT_RECONNECT")                }                socket?.on(Manager.EVENT_RECONNECT_FAILED) {                    Log.d(TAG, "EVENT_RECONNECT_FAILED")                }                socket?.on(Manager.EVENT_RECONNECT_ERROR) {                    Log.d(TAG, "EVENT_RECONNECT_ERROR")                }                // Connect the socket                socket?.connect()            } catch (e: UnknownHostException) {                Log.e(TAG, "Unknown host.", e)            } catch (e: SocketTimeoutException) {                Log.e(TAG, "Connection timed out.", e)            } catch (e: SocketException) {                Log.e(TAG, "A socket error occurred.", e)            } catch (e: IOException) {                Log.e(TAG, "An I/O error occurred while creating the socket.", e)            } catch (e: Exception) {                Log.e(TAG, "An unexpected error occurred while initializing the socket.", e)            }            socketInitializationDeferred?.takeIf { !it.isCompleted }?.await()        }    }    // Start heartbeat using coroutines    private fun startHeartbeat() {        // Start the heartbeat coroutine        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {            sendHeartbeatPeriodically()        }    }    // A suspend function that sends heartbeat periodically    private suspend fun sendHeartbeatPeriodically() {        while (true) { // Check if the coroutine is still active            socket?.let {                if (it.connected()) {                    it.emit("chat:heartbeat") // Send heartbeat to the server                } else {                    stopHeartbeat()                }            } ?: run {                stopHeartbeat()            }            delay(2000) // Delay before sending the next heartbeat (2 seconds)        }    }    private fun stopHeartbeat() {        heartbeatJob?.cancel() // Cancel the heartbeat coroutine when the ViewModel is cleared    }    // Destroy the socket connection    fun destroySocket() {        socket?.disconnect()        socket = null        _socketFlow.value = null // Emit null when socket is destroyed    }    private fun chatMessageProcessor(data: JSONObject, userId: Long) {        val senderId = data.getLong("sender")        val messageId = data.getLong("message_id")        val replyId = data.getLong("reply_id")        val type = data.getString("type")        val encryptedMessage = data.getString("message")        val category = data.getString("category")        val keyVersion = data.optLong("key_version") // Please check it        CoroutineScope(Dispatchers.IO).launch {            val chatUser = chatUserDao.getChatUserByRecipientId(senderId)            if (chatUser == null) {                withContext(Dispatchers.Main) {                    // After cancellation, enqueue new work for fetching user profile                    ChatMessageHandlerWorkerHelper.enqueueFetchUserProfileWork(                        application,                        userId,                        senderId,                        messageId,                        data.toString()                    )                }            } else {                if (category.contains("image") || category.contains("video") || category.contains("gif")) {                    ChatMessageHandlerWorkerHelper.visualMediaChatMessageProcessor(                        application,                        data,                        chatUser.chatId,                        chatUser.recipientId,                        senderId,                        replyId,                        messageId,                        encryptedMessage                    )                } else if (category.contains("audio")) {                    // Create input data to pass the FCM token to the worker                    val fileMetadata = JSONObject(data.getString("file_metadata"))                    val originalFileName = fileMetadata.optString("original_file_name")                    val fileSize = fileMetadata.optLong("file_size")                    val contentType = fileMetadata.optString("content_type")                    val fileExtension = fileMetadata.optString("extension")                    val totalDuration = fileMetadata.optLong("total_duration")                    val downloadUrl = fileMetadata.optString("download_url")                    CoroutineScope(Dispatchers.IO)                        .launch {                            messageDao.insertMessageAndMetadata(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = encryptedMessage,                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.SENDING,                                    type = ChatMessageType.AUDIO,                                ),                                fileMetaDataDao,                                MessageMediaMetadata(                                    messageId = -1,                                    fileDownloadUrl = downloadUrl,                                    fileSize = fileSize,                                    fileMimeType = contentType,                                    fileExtension = fileExtension,                                    originalFileName = originalFileName,                                    totalDuration = totalDuration                                )                            )                        }                    socket?.emit("chat:acknowledgment", JSONObject().apply {                        put("status", "delivered")                        put("sender", senderId)                        put("recipient_id", chatUser.recipientId)                        put("message_id", messageId)                    }, Ack {                        // Handle acknowledgment from the server                        Log.d(TAG, "Acknowledgment received by client")                    })                } else if (category.contains("file")) {                    // Create input data to pass the FCM token to the worker                    val fileMetadata = JSONObject(data.getString("file_metadata"))                    val originalFileName = fileMetadata.optString("original_file_name")                    val fileSize = fileMetadata.optLong("file_size")                    val contentType = fileMetadata.optString("content_type")                    val fileExtension = fileMetadata.optString("extension")                    val downloadUrl = fileMetadata.optString("download_url")                    CoroutineScope(Dispatchers.IO)                        .launch {                            messageDao.insertMessageAndMetadata(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = encryptedMessage,                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.SENDING,                                    type = ChatMessageType.FILE,                                    ),                                fileMetaDataDao,                                MessageMediaMetadata(                                    messageId = -1,                                    fileDownloadUrl = downloadUrl,                                    fileSize = fileSize,                                    fileMimeType = contentType,                                    fileExtension = fileExtension,                                    originalFileName = originalFileName,                                )                            )                        }                    socket?.emit("chat:acknowledgment", JSONObject().apply {                        put("status", "delivered")                        put("sender", senderId)                        put("recipient_id", chatUser.recipientId)                        put(                            "message_id",                            messageId                        ) // Add the inserted message ID to JSON                    }, Ack {                        // Handle acknowledgment from the server                        Log.d(TAG, "Acknowledgment received by client")                    })                } else if (category.contains("others")) {                    // Create input data to pass the FCM token to the worker                    val fileMetadata = JSONObject(data.getString("file_metadata"))                    val originalFileName = fileMetadata.optString("original_file_name")                    val fileSize = fileMetadata.optLong("file_size")                    val contentType = fileMetadata.optString("content_type")                    val fileExtension = fileMetadata.optString("extension")                    val totalDuration = fileMetadata.optLong("total_duration")                    val downloadUrl = fileMetadata.optString("download_url")                    CoroutineScope(Dispatchers.IO)                        .launch {                            messageDao.insertMessageAndMetadata(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = encryptedMessage,                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.SENDING,                                    type = ChatMessageType.FILE                                ),                                fileMetaDataDao,                                MessageMediaMetadata(                                    messageId = -1,                                    fileDownloadUrl = downloadUrl,                                    fileSize = fileSize,                                    fileMimeType = contentType,                                    fileExtension = fileExtension,                                    originalFileName = originalFileName,                                )                            )                        }                    socket?.emit("chat:acknowledgment", JSONObject().apply {                        put("status", "delivered")                        put("sender", senderId)                        put("recipient_id", chatUser.recipientId)                        put("message_id", messageId) // Add the inserted message ID to JSON                    }, Ack {                        // Handle acknowledgment from the server                        Log.d(TAG, "Acknowledgment received by client")                    })                } else {                    when (val decryptionStatus = decryptMessage(encryptedMessage)) {                        is DecryptionStatus.DecryptionFailed -> {                            messageDao.insertMessage(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = "",                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.FAILED_TO_DISPLAY_REASON_DECRYPTION_FAILED                                )                            )                        }                        is DecryptionStatus.UnknownError -> {                            messageDao.insertMessage(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = "",                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.FAILED_TO_DISPLAY_REASON_UNKNOWN                                )                            )                        }                        is DecryptionStatus.Success -> {                            messageDao.insertMessage(                                Message(                                    chatId = chatUser.chatId,                                    senderId = senderId,                                    recipientId = chatUser.userId,                                    content = decryptionStatus.decryptedMessage,                                    timestamp = System.currentTimeMillis(),                                    senderMessageId = messageId,                                    replyId = replyId,                                    status = ChatMessageStatus.SENDING                                )                            )                        }                    }                    socket?.emit("chat:acknowledgment", JSONObject().apply {                        put("status", "delivered")                        put("sender", senderId)                        put("recipient_id", chatUser.recipientId)                        put(                            "message_id",                            messageId                        ) // Add the inserted message ID to JSON                    }, Ack {                        // Handle acknowledgment from the server                        Log.d(TAG, "Acknowledgment received by client")                    })                }            }        }    }}